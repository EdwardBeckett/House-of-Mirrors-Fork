package hom

import java.io.{File,FileWriter}
import scala.xml.{Elem,Node,Unparsed,XML}

import Directions._
import LineColors._

import XMLable._

object GameLevel {
  def apply(resource: Resource, n: Int): GameLevel = {
    require(resource != null)
    fromXML(resource.loadXML(), n)
  }

  def fromXML(topElem: Elem, n: Int): GameLevel = {

    def parseGates(node: Node, typeName: String) = (node \\ typeName)(0).descendant.map(_ match {
      case s @ <Source/> => { val u: UnXMLable[Source] = s; u.fromXML }
      case s @ <Conduit/> => { val u: UnXMLable[Conduit] = s; u.fromXML }
      case s @ <Mirror/> => { val u: UnXMLable[Mirror] = s; u.fromXML }
      case s @ <Prism/> => { val u: UnXMLable[Prism] = s; u.fromXML }
      case s @ <PartialMirror/> => { val u: UnXMLable[PartialMirror] = s; u.fromXML }
      case s @ <CrossMirror/> => { val u: UnXMLable[CrossMirror] = s; u.fromXML }
      case s @ <Detector/> => { val u: UnXMLable[Detector] = s; u.fromXML }
      case s @ <Blocker/> => { val u: UnXMLable[Blocker] = s; u.fromXML }
      case s @ <WormHole/> => { val u: UnXMLable[FixedWormHole] = s; u.fromXML }
    })

    def parseMoveableGates(node: Node, typeName: String) = (node \\ typeName)(0).descendant.map(_ match {
      case s @ <Source/> => { val u: UnXMLable[MoveableSource] = s; u.fromXML }
      case s @ <Conduit/> => { val u: UnXMLable[MoveableConduit] = s; u.fromXML }
      case s @ <Mirror/> => { val u: UnXMLable[MoveableMirror] = s; u.fromXML }
      case s @ <Prism/> => { val u: UnXMLable[MoveablePrism] = s; u.fromXML }
      case s @ <PartialMirror/> => { val u: UnXMLable[MoveablePartialMirror] = s; u.fromXML }
      case s @ <CrossMirror/> => { val u: UnXMLable[MoveableCrossMirror] = s; u.fromXML }
      case s @ <Detector/> => { val u: UnXMLable[MoveableDetector] = s; u.fromXML }
      case s @ <Blocker/> => { val u: UnXMLable[MoveableBlocker] = s; u.fromXML }
      case s @ <WormHole/> => { val u: UnXMLable[MoveableWormHole] = s; u.fromXML }
    })

    def parseBound(node: Node): Bound = {
      val myBoundsNode = (node \\ "bounds")(0)
      val u: UnXMLable[Bound] = myBoundsNode
      u.fromXML
    }

    val trimTop = scala.xml.Utility.trim(topElem)
    val bounds = parseBound((trimTop \\ "bounds")(0))

    val fixed_gates = parseGates(trimTop, "fixedGates")
    val moveable_gates = parseMoveableGates(trimTop, "moveableGates")

    // wormholes don't know their twins yet; for fun, handle the case of one is moveable but the other is fixed
    for (one <- fixed_gates if (one.isInstanceOf[WormHole] && one.asInstanceOf[WormHole].twin == null)) {
      val cur = one.asInstanceOf[WormHole]
      // look among other fixed gates (self-test should fail)
      for (two <- fixed_gates if (two.isInstanceOf[WormHole] && two.asInstanceOf[WormHole].position == cur.other)) {
        val other = two.asInstanceOf[WormHole]
        cur.twin = other
        other.twin = cur
      }
      // look among moveable gates
      if (cur.twin == null) {
        for (two <- moveable_gates if (two.isInstanceOf[WormHole] && two.asInstanceOf[WormHole].position == cur.other)) {
          val other = two.asInstanceOf[WormHole]
          cur.twin = other
          other.twin = cur
        }
      }
    }
    // any remaining are pairs which are both moveable
    for (one <- moveable_gates if (one.isInstanceOf[WormHole] && one.asInstanceOf[WormHole].twin == null)) {
      val cur = one.asInstanceOf[WormHole]
      // look among other moveable gates (self-test should fail)
      for (two <- moveable_gates if (two.isInstanceOf[WormHole] && two.asInstanceOf[WormHole].position == cur.other)) {
        val other = two.asInstanceOf[WormHole]
        cur.twin = other
        other.twin = cur
      }
    }

    val description = (trimTop \\ "description")(0).child.foldLeft("")(_ + _.toString)
    return new GameLevel(n, description, bounds, fixed_gates, moveable_gates)
  }

  def toXML(g: GameLevel): Elem = {
    <houseofmirrors >
      <description>{Unparsed(g.description)}</description>
      <bounds width={g.bounds.width.toString} height={g.bounds.height.toString} />
      <fixedGates>{g.fixed_gates.map(f => f.toXML)}</fixedGates>
      <moveableGates>{g.moveable_gates.map(m => m.toXML)}</moveableGates>
    </houseofmirrors>
  }
}

/**
 * Models a game level as a grid with gate objects.
 * Moveable gates can be moved and rotated.
 * Current board state is generated by trace, which calculates light paths as line segments and current gate states.
 */
class GameLevel(val level: Int, val description: String, val bounds: Bound, val fixed_gates: List[Gate], var moveable_gates: List[Gate]) {

  def gates = fixed_gates ::: moveable_gates

  /**
   * A chance to free resources on shutdown.
   */
  def dispose() {
    //empty
  }

  def occupied(p: Point) = {
    this.gates.find(g => g.position == p).isDefined
  }

  def turnCCW(p: Point): Boolean = {
    var result: Boolean = false
    this.moveable_gates = this.moveable_gates.map(g => if (g.position == p) { result = true; g.asInstanceOf[Turnable].turnCCW } else g)
    return result
  }

  def turnCW(p: Point): Boolean = {
    var result: Boolean = false
    this.moveable_gates = this.moveable_gates.map(g => if (g.position == p) { result = true; g.asInstanceOf[Turnable].turnCW } else g)
    return result
  }

  def moveUp(p: Point) = moveTo(p, p.moveUp)

  def moveDown(p: Point) = moveTo(p, p.moveDown)

  def moveLeft(p: Point) = moveTo(p, p.moveLeft)

  def moveRight(p: Point) = moveTo(p, p.moveRight)

  def moveTo(from: Point, target: Point): Boolean = {
    if (this.bounds.contains(target) && !occupied(target)) {
      this.moveable_gates = moveable_gates.map(g => if (g.position == from) g.asInstanceOf[Moveable].moveTo(target) else g)
      true
    } else {
      false
    }
  }

  private def sourceRays: List[Ray] = this.gates.flatMap(g =>
    g match {
      case s: Source => s.emit()
      case _ => Nil
    }
  )

  /** Derive the light rays and gate states (i.e., whether Detectors are detecting) from the current board model. */
  def trace: GameState = {
    val (segments, revisedGates) = shootRayList(sourceRays, this.gates, Nil)
    //println(segments.length + " Trace segments " + segments)
    val status = this.status(revisedGates)
    return new GameState(segments, revisedGates, status)
  }

  private def status(g: List[Gate]): StatusUpdate = {
    val detectors = g.filter (_.isInstanceOf[Detector]).map(_.asInstanceOf[Detector])
    val numOn = detectors.foldLeft(0)((sum, d) => if (d.isOn) sum + 1 else sum)
    val totalDetectors = detectors.length
    return new StatusUpdate(this.description, numOn, totalDetectors)
  }

  /** Shoots a ray, and gives a list of resulting line-segments */
  private def shootRay(r: Ray, gateList: List[Gate], visitedGates: List[(Gate, Direction, LineColor)]): (List[Segment], List[Gate]) = {
    var traceSegment : List[Segment] = Nil
    var traceGate : List[Gate] = gateList

    var prevPoint = r.start
    var point = r.nextPoint(prevPoint)
    var done = false
    while (!done && this.bounds.containsOneOff(point)) {
      gateList.find(g => g.position == point) match {
        case Some(gate) => {
          def addUniqueGate(gate: Gate, gates: List[Gate]) = gate :: gates.filterNot(g => g.position == gate.position)

          if (!visitedGates.contains((gate, r.direction, r.color))) {
            val (rays, newgate) = gate.act(r)

            //println(gate + " shoots " + rays + " and becomes " + newgate)
            traceGate = addUniqueGate(newgate, traceGate)

            val returnList = shootRayList(rays, traceGate, (gate, r.direction, r.color) :: visitedGates)
            traceSegment = returnList._1
            traceGate = returnList._2
          }
          prevPoint = point
          done = true
        }
        case None => {
          prevPoint = point
          point = r.nextPoint(point)
        }
      }
    }
    val returnGates = gateList.filterNot(x => traceGate.find(y => y.position == x.position).isDefined)
    (new Segment(r.start, prevPoint, r.color) :: traceSegment , traceGate ::: returnGates)
  }

  private def shootRayList(rays: List[Ray], gateList: List[Gate], visitations: List[(Gate, Direction, LineColor)]) = {
    var segments: List[Segment] = Nil
    var revisedGates: List[Gate] = gateList

    rays.foreach(ray => {
      val (resultSegments, resultGates) = shootRay(ray, revisedGates, visitations)
      segments = resultSegments ::: segments
      revisedGates = resultGates
    })
    (segments, revisedGates)
  }

  def toXML(): Elem = GameLevel.toXML(this)
}

class GameState(val segments: List[Segment], val gates: List[Gate], val status: StatusUpdate)

case class StatusUpdate(description: String, score: Int, total: Int) {
  def isComplete: Boolean = score == total
}

